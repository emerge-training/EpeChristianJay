import jk.log
import jk.sqlite
import jk.mysql
import jk.sql
import jk.env
import jk.time


class:

model Note
{
    noteId as string
    title as string
    author as string
    description as string
    timeStampAdded as long
    timeStampLastUpdated as long
}

pvar db as MySQLDatabase

func forContext(ctx as LoggingContext) static as this
{
    var cstr = EnvironmentVariable.get("NOTELIST_DATABASE")
    Log.debug(ctx, "Opening database connection: `"..cstr.."'")
    db = MySQLDatabase.forConnectionStringSync(ctx, cstr)
    if not db:
        Error.throw("failedToConnectToDatabase",cstr)
    var v = new this()
    v.setDb(db)
    return v
}

func updateTable(table as SQLTableInfo)
{
    if not table:
        Error.throw("nullTable","updateTable")
    if not db: 
        Error.throw("nullDb", "updateTable")
    if not db.ensureTableExistsSync(table):
        Error.throw("failedToUpdateTable", table.getName())
}

func updateTables
{
    /*Logging Context
        Example for Note Models 
    */
    var table_note = SQLTableInfo.forName("NOTE_TABLE")
    table_note.addStringKeyColumn("noteId")
    table_note.addStringColumn("title")
    table_note.addStringColumn("author")
    table_note.addStringColumn("description")
    table_note.addLongColumn("timeStampAdded")
    table_note.addLongColumn("timeStampLastUpdated")
    updateTable(table_note)

}

func addNote(note as Note) as Note
{   
    assert note
    note.setNoteId("1")
    note.setTimeStampAddedValue(SystemClock.asUTCSeconds())
    assert db.executeSync(db.prepareInsertStatementSync("NOTE_TABLE",note.toDynamicMap()))
    return note
}

func updateNote(id as string, note as Note) as bool
{
    assert note
    note.setTimeStampLastUpdatedValue(SystemClock.asUTCSeconds())
    var criteria = new Note()
    criteria.setNoteId(id)
    return db.executeSync(db.prepareUpdateStatementSync("NOTE_TABLE", criteria.toDynamicMap(), note.toDynamicMap()))
}



func deleteNote(id as string) as bool
{
    var criteria = new Note()
    criteria.setNoteId(id)
    return db.executeSync(db.prepareDeleteStatementSync("NOTE_TABLE", criteria.toDynamicMap()))
}

 func getNote as DynamicMap
 {
    var vec = new vector<Note>
    var data = assert db.querySync(db.prepareQueryAllStatementSync("NOTE_TABLE")):
        return null
    while data{
        var object  = data.next()
        if not object:
            break
        var note = Note.forJsonObject(object)
        if not note:
            continue
        vec += note
    }
 }

func close
{
    if db:
        db.closeSync()
    db = null
}

